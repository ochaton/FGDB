# FGDB и NoSQL Key-Value DataBase

## Содержание

+ Технические требования
+ Объектная модель
+ RFC поиска ключей
+ RFC работы с диском
+ RFC обслуживание клиента
+ Декомпозированные задачи

## 1. Технические требования
Нам нужно написать Key-Value DB. Длина ключа до 1Кб. Все ключи должны помещаться в RAM, на это может быть выделено 1-2ГБ. Проверка наличия ключа должна осуществляться за O(#key). Предполагается работа с данными до 100Гб. Предполагается, что БД будет работать на 2-(4-)х ядерном процессоре. БД обязана поддерживать описанный бинарный протокол и выполнять операции `SELECT`, `UPDATE`, `INSERT`, `DELETE`, `PEEK` за разумное время. БД обязана обеспечить атомарный, консистентный, изоллированный, устойчивый доступ к данными. База Данных должна бороться с фрагментированными данными на диске.

## 2. Объектная модель

### Block-page (HDD)
Данные хранятся блоками (page) на жестком диске. #page = 4Kb
По типу, page делятся на:
1. Meta-page: страницы, хранящие отображение key => value, value := page + offset
2. Value-Page: страницы, хранящие values.

Value может превышать размер страницы, но тогда обязана быть выровнена на начало страницы. Каждая страница может хранить несколько значений, но только тогда, когда все они помещаются на страницу. Страница, хранящаяся на диске обязана быть дефрагментирована.

### Keys' hash-map
Перед началом работы с БД, необходимо построить многоуровневый hash-map для ключей. Таким образом, проверка наличия ключа в БД будет осуществляться максимально быстро. Данный hash-map, представляет отображение в page+offset на диске, а также на область оперативной памяти, если данный page в нее загружен.

### Page-Cache (Buffer manager)
Page-Cache представляет собой LRU-кэш Value-page с диска, находящихся в RAM. Его частью является обратный индекс, Value-Page+offset => Key, для эффективного проведения дефрагментации. Страницы в Page-Cache могут находиться в фрагментированном (Dirty) состоянии. Для упрощения дефрагментации, необходима Структура Данных, позволяющая за O(1) найти горячую страницу с максимальным свободным местом, для проведения операций Insert/Update.

### Transaction Queue
Каждое клиентское обращение к данным, по сути, является транзакцией. Transaction Queue является приоритетной очередью, со следующим разбиением по приоритету операций:
1. PEEK
2. SELECT
3. INSERT/UPDATE/DELETE

Транзакции выполняются в порядке их пополнения в очередь. *Все операции выполняются на прогретых данных*

### WAL-logs
Для обеспечения устойчивости БД, перед выполнением любого модифицирующего запроса к данным, необходимо синхронно записать бинарный лог, выполняя который, можно перейти от текущего состояния БД к следующему, при наличии начального состояния БД.

### Page-Dumper
Отдельный тред, обеспечивающий взаимодействие с диском, а именно прогрев и охлаждение страниц. Прогрев может происходить постранично. Охлаждение выполняется только над небольшим количеством страниц, перед этим проводя дефрагментацию с обновлением Дерева Ключей.

## 3. RFC поиска ключей
Перед выполнением любой операции над данными, необходимо убедиться о наличии данного ключа в БД. Для этого, от ключа берется 4-х уровневый хеш с разными модулями, после происходит работа с коллизиями (если они возникли), а именно поиск по небольшому префиксному дереву. В результате O(#key) сложность проверки ключа. В качестве значения получаем структуру с page+offset и флагом прогретости данных.

## 4. RFC работы с диском
Все Meta-pages объединены в связанный список, который просматривается в одну сторону единожды при старте БД и поднимается в память. При возврате Value, прогревается вся страница целиком. Страницы в памяти хранятся в виде AVL-дерева по свободному месту и связанному списку для LRU.
LRU-Cache   := Lsn + [Pages]
Page        := Lsn + FreeSpace + [Value] + NextPage
Value       := PackedValue + pKey
PackedValue := Len + Binary
pKey == pointer to key inside Keys' hash-map
NextPage == pointer to next page inside LRU-Cache

Прогрев страницы:
1. Seek
2. Page.Lsn = LRU-Cache.Lsn++ / 3
3. Построение обратного индекса в Keys' hash-map
4. Обновление флага в Keys' hash-map

Охлаждение страниц:
1. Запускается по таймеру или по требованию
2. Дефрагментация values внутри страниц.
3. Обновление Keys' hash-map
4. Write на диск
5. Удаление из LRU-cache

DELETE:
1. Проверка наличия ключа
2. Удаление ключа из Keys' hash-map
3. Обновление свободного места в page

INSERT:
1. Проверка отсутствия ключа
2. Поиск максимально свободной страницы по AVL =
	1. При наличии -> обновление данных
	2. При отсутствии -> заведение новой страницы

UPDATE = DELETE + INSERT

SELECT:
1. Возврат значения по ключу

## 5. RFC обслуживание клиента
Для работы с клиентским соединением используется libev и messagepack. При успешном парсинге, транзакция, запрошенная клиентом, добавляется в Transaction Queue на исполнение другим тредом.

Выполняется поиск page по ключу, прогрев страницы, с вытеснением страниц из кеша при необходимости, выполнение операции и возврат результата пользователю. Для обеспечения равноправности используется приоритетная очередь. Запросы SELECT и PEEK выполняются по полному совпадению ключа.

## 6. Декомпозиция

1. Продумать и реализовать работу с форматом meta-page и value-page (Page Dumper).
	1. Seek для value-page
	2. Составление Keys' hash-map по meta-pages
	3. Read страницы в RAM
	4. Добавление новой страницы
	5. Сброс страницы на диск
2. Реализовать Keys' hash-map:
	1. Поиск по ключу
	2. Добавление нового ключа
	3. Выбор хеш-функции и делителей
	4. Обновление данных по ключу
	5. Удаление ключа
3. LRU-Cache:
	1. Формат структуры кэша
	2. AVL-дерево и связанный список
	3. Дефрагментация нескольких страниц
	4. Построение обратного индекса в Keys' hash-map
	5. Работа с Dirty-pages
	6. Контроль свободного пространства внутри page
	7. Добавление страницы в кеш и её вымещение
	8. Таймер
4. Transaction Queue:
	1. Приоритетная очередь
	2. Добавление и удаление транзакции
5. Основная связующая логика:
	1. Положить в очередь
	2. Достать из очереди
	3. Проверить Keys' hash-map
		1. Отловить ошибки
	4. Проверить кэш
		1. При отсутствии:
			1. Заставить другой тред достать страницу
			2. Положить в кеш
			3. Выполнить транзакцию
		2. При наличии:
			1. Выполнить транзакцию
			2. Актуализировать LRU
	5. Вернуть ответ клиенту
